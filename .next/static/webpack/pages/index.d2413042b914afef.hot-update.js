"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./lib/sdf-morph.js":
/*!**************************!*\
  !*** ./lib/sdf-morph.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NUM_COLORS: function() { return /* binding */ NUM_COLORS; },\n/* harmony export */   drawImageBottomCenter: function() { return /* binding */ drawImageBottomCenter; },\n/* harmony export */   drawMorphFrame: function() { return /* binding */ drawMorphFrame; },\n/* harmony export */   drawSdfMorph: function() { return /* binding */ drawSdfMorph; },\n/* harmony export */   generateImageData: function() { return /* binding */ generateImageData; },\n/* harmony export */   nearestColorInPalette: function() { return /* binding */ nearestColorInPalette; },\n/* harmony export */   unionPalettes: function() { return /* binding */ unionPalettes; }\n/* harmony export */ });\n/* Pure utilities – no React */ /*────────────────── constants ──────────────────*/ const NUM_COLORS = 6;\n/*────────────────── helpers ──────────────────*/ function drawImageBottomCenter(ctx, src, w, h, cw, ch) {\n    const img = new Image();\n    img.crossOrigin = \"anonymous\";\n    img.onload = ()=>ctx.drawImage(img, (cw - w) / 2, ch - h);\n    img.src = src;\n}\nfunction nearestColorInPalette(param, pal) {\n    let [r, g, b, a] = param;\n    var _pal;\n    if (!((_pal = pal) === null || _pal === void 0 ? void 0 : _pal.length)) return [\n        r | 0,\n        g | 0,\n        b | 0,\n        a | 0\n    ];\n    let best = pal[0], bestD = 1 / 0;\n    for (const c of pal){\n        const d = (c[0] - r) ** 2 + (c[1] - g) ** 2 + (c[2] - b) ** 2 + (c[3] - a) ** 2;\n        if (d < bestD) {\n            bestD = d;\n            best = c;\n        }\n    }\n    return best;\n}\nfunction unionPalettes(a, b) {\n    const seen = new Set([\n        ...a,\n        ...b\n    ].map((c)=>c.join(\",\")));\n    return [\n        ...seen\n    ].map((s)=>s.split(\",\").map((n)=>+n));\n}\n/*────────────────── low-level raster ──────────────────*/ /**\n * Draw a single blended/clamped pixel-perfect frame.\n * @param {CanvasRenderingContext2D} ctx target context\n * @param {*} fromImg  pre-processed imageA (generateImageData)\n * @param {*} toImg    pre-processed imageB (generateImageData)\n * @param {number} cw  canvas width  (max of sprite widths)\n * @param {number} ch  canvas height (max of sprite heights)\n * @param {number} t   0…1 morph progress\n * @param {number[][]} pal  palette to clamp to\n * @param {number} quant 0 = raw blend, 1 = full palette snap\n */ function drawSdfMorph(ctx, fromImg, toImg, cw, ch, t, pal) {\n    let quant = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 1;\n    const out = ctx.createImageData(cw, ch);\n    const d = out.data;\n    const oXA = cw - fromImg.width >> 1, oYA = ch - fromImg.height;\n    const oXB = cw - toImg.width >> 1, oYB = ch - toImg.height;\n    for(let y = 0; y < ch; y++){\n        for(let x = 0; x < cw; x++){\n            const i = y * cw + x << 2;\n            let sdA = 1e9, cA = [\n                0,\n                0,\n                0,\n                0\n            ];\n            let lx = x - oXA, ly = y - oYA;\n            if (lx >= 0 && ly >= 0 && lx < fromImg.width && ly < fromImg.height) {\n                sdA = fromImg.sdf[ly][lx];\n                cA = fromImg.allColors[ly][lx];\n            }\n            let sdB = 1e9, cB = [\n                0,\n                0,\n                0,\n                0\n            ];\n            lx = x - oXB;\n            ly = y - oYB;\n            if (lx >= 0 && ly >= 0 && lx < toImg.width && ly < toImg.height) {\n                sdB = toImg.sdf[ly][lx];\n                cB = toImg.allColors[ly][lx];\n            }\n            const sd = sdA * (1 - t) + sdB * t;\n            if (sd >= 0) {\n                d[i + 3] = 0;\n                continue;\n            }\n            const mix = [\n                (1 - t) * cA[0] + t * cB[0],\n                (1 - t) * cA[1] + t * cB[1],\n                (1 - t) * cA[2] + t * cB[2],\n                (1 - t) * cA[3] + t * cB[3]\n            ];\n            const palC = nearestColorInPalette(mix, pal);\n            d[i + 0] = mix[0] * (1 - quant) + palC[0] * quant;\n            d[i + 1] = mix[1] * (1 - quant) + palC[1] * quant;\n            d[i + 2] = mix[2] * (1 - quant) + palC[2] * quant;\n            d[i + 3] = mix[3] * (1 - quant) + palC[3] * quant;\n        }\n    }\n    ctx.putImageData(out, 0, 0);\n}\n/*────────────────── high-level frame helper ──────────────────*/ /**\n * Convenience: draws frameIndex of a 15-frame morph (default layout).\n * Handles first/last frame blits and palette selection.\n */ function drawMorphFrame(ctx, fromImg, toImg, frameIdx) {\n    let totalFrames = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 15, quant = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;\n    const cw = Math.max(fromImg.width, toImg.width);\n    const ch = Math.max(fromImg.height, toImg.height);\n    const t = (frameIdx - 1) / (totalFrames - 1);\n    if (frameIdx === 1) return drawImageBottomCenter(ctx, fromImg.url, fromImg.width, fromImg.height, cw, ch);\n    if (frameIdx === totalFrames) return drawImageBottomCenter(ctx, toImg.url, toImg.width, toImg.height, cw, ch);\n    const pal = frameIdx <= 6 ? fromImg.topN : frameIdx <= 9 ? unionPalettes(fromImg.topN, toImg.topN) : toImg.topN;\n    drawSdfMorph(ctx, fromImg, toImg, cw, ch, t, pal, quant);\n}\n/*────────────────── preprocessing (unchanged) ──────────────────*/ function generateImageData(img) {\n    let topN = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : NUM_COLORS;\n    const { width: w, height: h } = img;\n    const can = new OffscreenCanvas(w, h);\n    const c = can.getContext(\"2d\", {\n        willReadFrequently: true\n    });\n    c.drawImage(img, 0, 0);\n    const d = c.getImageData(0, 0, w, h).data;\n    const colours = Array.from({\n        length: h\n    }, ()=>Array(w));\n    const inside = new Uint8Array(w * h);\n    const freq = new Map();\n    for(let i = 0; i < d.length; i += 4){\n        const idx = i >> 2, x = idx % w, y = idx / w | 0;\n        const rgba = [\n            d[i],\n            d[i + 1],\n            d[i + 2],\n            d[i + 3]\n        ];\n        colours[y][x] = rgba;\n        if (rgba[3] > 20) {\n            inside[idx] = 1;\n            freq.set(rgba.join(\",\"), (freq.get(rgba.join(\",\")) || 0) + 1);\n        }\n    }\n    const boundary = [];\n    for(let y = 0; y < h; y++)for(let x = 0; x < w; x++){\n        const idx = y * w + x, inS = inside[idx];\n        for(let dy = -1; dy <= 1 && !boundary[idx]; dy++)for(let dx = -1; dx <= 1; dx++){\n            if (!dx && !dy) continue;\n            const nx = x + dx, ny = y + dy;\n            if (nx < 0 || ny < 0 || nx >= w || ny >= h) continue;\n            if (inside[ny * w + nx] !== inS) boundary.push({\n                x,\n                y\n            }), dy = 2;\n        }\n    }\n    const sdf = Array.from({\n        length: h\n    }, ()=>Array(w));\n    for(let y = 0; y < h; y++)for(let x = 0; x < w; x++){\n        let m = 1 / 0;\n        for (const b of boundary){\n            const dx = b.x - x, dy = b.y - y, d2 = dx * dx + dy * dy;\n            if (d2 < m) m = d2;\n        }\n        sdf[y][x] = (inside[y * w + x] ? -1 : 1) * Math.sqrt(m);\n    }\n    const top = [\n        ...freq\n    ].sort((a, b)=>b[1] - a[1]).slice(0, topN).map((param)=>{\n        let [k] = param;\n        return k.split(\",\").map((n)=>+n);\n    });\n    return {\n        sdf,\n        allColors: colours,\n        topN: top,\n        width: w,\n        height: h,\n        url: img.src\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxJQUFFLElBQUU7UUFDUixLQUFJLE1BQU0zRSxLQUFLb0UsU0FBUztZQUN0QixNQUFNRyxLQUFHdkUsRUFBRThCLENBQUMsR0FBQ0EsR0FBRXdDLEtBQUd0RSxFQUFFNkIsQ0FBQyxHQUFDQSxHQUFHK0MsS0FBR0wsS0FBR0EsS0FBR0QsS0FBR0E7WUFDckMsSUFBR00sS0FBR0QsR0FBRUEsSUFBRUM7UUFDWjtRQUNBeEMsR0FBRyxDQUFDUCxFQUFFLENBQUNDLEVBQUUsR0FBQyxDQUFDOEIsTUFBTSxDQUFDL0IsSUFBRTFDLElBQUUyQyxFQUFFLEdBQUUsQ0FBQyxJQUFFLEtBQUdpQixLQUFLOEIsSUFBSSxDQUFDRjtJQUM1QztJQUVBLE1BQU1HLE1BQU07V0FBSWhCO0tBQUssQ0FBQ2lCLElBQUksQ0FBQyxDQUFDOUUsR0FBRUQsSUFBSUEsQ0FBQyxDQUFDLEVBQUUsR0FBQ0MsQ0FBQyxDQUFDLEVBQUUsRUFDN0IrRSxLQUFLLENBQUMsR0FBRTlCLE1BQ1J4QyxHQUFHLENBQUM7WUFBQyxDQUFDdUUsRUFBRTtlQUFHQSxFQUFFcEUsS0FBSyxDQUFDLEtBQUtILEdBQUcsQ0FBQ0ksQ0FBQUEsSUFBRyxDQUFDQTtJQUFDO0lBQy9DLE9BQU87UUFBRXNCO1FBQUtDLFdBQVdvQjtRQUFTUCxNQUFNNEI7UUFBS3RELE9BQU1yQztRQUFHdUMsUUFBT3RDO1FBQUc2RCxLQUFLMUQsSUFBSUwsR0FBRztJQUFDO0FBQy9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9zZGYtbW9ycGguanM/YTk1MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBQdXJlIHV0aWxpdGllcyDigJMgbm8gUmVhY3QgKi9cblxuLyrilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgY29uc3RhbnRzIOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgOKUgCovXG5leHBvcnQgY29uc3QgTlVNX0NPTE9SUyA9IDY7XG5cbi8q4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIGhlbHBlcnMg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAKi9cbmV4cG9ydCBmdW5jdGlvbiBkcmF3SW1hZ2VCb3R0b21DZW50ZXIoY3R4LCBzcmMsIHcsIGgsIGN3LCBjaCkge1xuICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gIGltZy5vbmxvYWQgPSAoKSA9PiBjdHguZHJhd0ltYWdlKGltZywgKGN3IC0gdykgLyAyLCBjaCAtIGgpO1xuICBpbWcuc3JjID0gc3JjO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmVhcmVzdENvbG9ySW5QYWxldHRlKFtyLCBnLCBiLCBhXSwgcGFsKSB7XG4gIGlmICghcGFsPy5sZW5ndGgpIHJldHVybiBbcnwwLCBnfDAsIGJ8MCwgYXwwXTtcbiAgbGV0IGJlc3QgPSBwYWxbMF0sIGJlc3REID0gMS8wO1xuICBmb3IgKGNvbnN0IGMgb2YgcGFsKSB7XG4gICAgY29uc3QgZCA9XG4gICAgICAoY1swXS1yKSoqMiArIChjWzFdLWcpKioyICtcbiAgICAgIChjWzJdLWIpKioyICsgKGNbM10tYSkqKjI7XG4gICAgaWYgKGQgPCBiZXN0RCkgeyBiZXN0RCA9IGQ7IGJlc3QgPSBjOyB9XG4gIH1cbiAgcmV0dXJuIGJlc3Q7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmlvblBhbGV0dGVzKGEsIGIpIHtcbiAgY29uc3Qgc2VlbiA9IG5ldyBTZXQoWy4uLmEsIC4uLmJdLm1hcChjID0+IGMuam9pbignLCcpKSk7XG4gIHJldHVybiBbLi4uc2Vlbl0ubWFwKHMgPT4gcy5zcGxpdCgnLCcpLm1hcChuID0+ICtuKSk7XG59XG5cbi8q4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIGxvdy1sZXZlbCByYXN0ZXIg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAKi9cbi8qKlxuICogRHJhdyBhIHNpbmdsZSBibGVuZGVkL2NsYW1wZWQgcGl4ZWwtcGVyZmVjdCBmcmFtZS5cbiAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBjdHggdGFyZ2V0IGNvbnRleHRcbiAqIEBwYXJhbSB7Kn0gZnJvbUltZyAgcHJlLXByb2Nlc3NlZCBpbWFnZUEgKGdlbmVyYXRlSW1hZ2VEYXRhKVxuICogQHBhcmFtIHsqfSB0b0ltZyAgICBwcmUtcHJvY2Vzc2VkIGltYWdlQiAoZ2VuZXJhdGVJbWFnZURhdGEpXG4gKiBAcGFyYW0ge251bWJlcn0gY3cgIGNhbnZhcyB3aWR0aCAgKG1heCBvZiBzcHJpdGUgd2lkdGhzKVxuICogQHBhcmFtIHtudW1iZXJ9IGNoICBjYW52YXMgaGVpZ2h0IChtYXggb2Ygc3ByaXRlIGhlaWdodHMpXG4gKiBAcGFyYW0ge251bWJlcn0gdCAgIDDigKYxIG1vcnBoIHByb2dyZXNzXG4gKiBAcGFyYW0ge251bWJlcltdW119IHBhbCAgcGFsZXR0ZSB0byBjbGFtcCB0b1xuICogQHBhcmFtIHtudW1iZXJ9IHF1YW50IDAgPSByYXcgYmxlbmQsIDEgPSBmdWxsIHBhbGV0dGUgc25hcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZHJhd1NkZk1vcnBoKGN0eCwgZnJvbUltZywgdG9JbWcsIGN3LCBjaCwgdCwgcGFsLCBxdWFudCA9IDEpIHtcbiAgY29uc3Qgb3V0ID0gY3R4LmNyZWF0ZUltYWdlRGF0YShjdywgY2gpO1xuICBjb25zdCBkICAgPSBvdXQuZGF0YTtcblxuICBjb25zdCBvWEEgPSAoY3cgLSBmcm9tSW1nLndpZHRoKSA+PiAxLCBvWUEgPSBjaCAtIGZyb21JbWcuaGVpZ2h0O1xuICBjb25zdCBvWEIgPSAoY3cgLSB0b0ltZy53aWR0aCkgICA+PiAxLCBvWUIgPSBjaCAtIHRvSW1nLmhlaWdodDtcblxuICBmb3IgKGxldCB5ID0gMDsgeSA8IGNoOyB5KyspIHtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGN3OyB4KyspIHtcbiAgICAgIGNvbnN0IGkgPSAoeSAqIGN3ICsgeCkgPDwgMjtcblxuICAgICAgbGV0IHNkQSA9IDFlOSwgY0EgPSBbMCwwLDAsMF07XG4gICAgICBsZXQgbHggPSB4IC0gb1hBLCBseSA9IHkgLSBvWUE7XG4gICAgICBpZiAobHg+PTAgJiYgbHk+PTAgJiYgbHg8ZnJvbUltZy53aWR0aCAmJiBseTxmcm9tSW1nLmhlaWdodCkge1xuICAgICAgICBzZEEgPSBmcm9tSW1nLnNkZltseV1bbHhdO1xuICAgICAgICBjQSAgPSBmcm9tSW1nLmFsbENvbG9yc1tseV1bbHhdO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2RCID0gMWU5LCBjQiA9IFswLDAsMCwwXTtcbiAgICAgIGx4ID0geCAtIG9YQjsgbHkgPSB5IC0gb1lCO1xuICAgICAgaWYgKGx4Pj0wICYmIGx5Pj0wICYmIGx4PHRvSW1nLndpZHRoICYmIGx5PHRvSW1nLmhlaWdodCkge1xuICAgICAgICBzZEIgPSB0b0ltZy5zZGZbbHldW2x4XTtcbiAgICAgICAgY0IgID0gdG9JbWcuYWxsQ29sb3JzW2x5XVtseF07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHNkID0gc2RBKigxLXQpICsgc2RCKnQ7XG4gICAgICBpZiAoc2QgPj0gMCkgeyBkW2krM10gPSAwOyBjb250aW51ZTsgfVxuXG4gICAgICBjb25zdCBtaXggPSBbXG4gICAgICAgICgxLXQpKmNBWzBdICsgdCpjQlswXSxcbiAgICAgICAgKDEtdCkqY0FbMV0gKyB0KmNCWzFdLFxuICAgICAgICAoMS10KSpjQVsyXSArIHQqY0JbMl0sXG4gICAgICAgICgxLXQpKmNBWzNdICsgdCpjQlszXSxcbiAgICAgIF07XG4gICAgICBjb25zdCBwYWxDID0gbmVhcmVzdENvbG9ySW5QYWxldHRlKG1peCwgcGFsKTtcblxuICAgICAgZFtpKzBdID0gbWl4WzBdKigxLXF1YW50KSArIHBhbENbMF0qcXVhbnQ7XG4gICAgICBkW2krMV0gPSBtaXhbMV0qKDEtcXVhbnQpICsgcGFsQ1sxXSpxdWFudDtcbiAgICAgIGRbaSsyXSA9IG1peFsyXSooMS1xdWFudCkgKyBwYWxDWzJdKnF1YW50O1xuICAgICAgZFtpKzNdID0gbWl4WzNdKigxLXF1YW50KSArIHBhbENbM10qcXVhbnQ7XG4gICAgfVxuICB9XG4gIGN0eC5wdXRJbWFnZURhdGEob3V0LCAwLCAwKTtcbn1cblxuLyrilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIDilIAgaGlnaC1sZXZlbCBmcmFtZSBoZWxwZXIg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAKi9cbi8qKlxuICogQ29udmVuaWVuY2U6IGRyYXdzIGZyYW1lSW5kZXggb2YgYSAxNS1mcmFtZSBtb3JwaCAoZGVmYXVsdCBsYXlvdXQpLlxuICogSGFuZGxlcyBmaXJzdC9sYXN0IGZyYW1lIGJsaXRzIGFuZCBwYWxldHRlIHNlbGVjdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRyYXdNb3JwaEZyYW1lKGN0eCwgZnJvbUltZywgdG9JbWcsIGZyYW1lSWR4LCB0b3RhbEZyYW1lcyA9IDE1LCBxdWFudCA9IDEpIHtcbiAgY29uc3QgY3cgPSBNYXRoLm1heChmcm9tSW1nLndpZHRoLCB0b0ltZy53aWR0aCk7XG4gIGNvbnN0IGNoID0gTWF0aC5tYXgoZnJvbUltZy5oZWlnaHQsIHRvSW1nLmhlaWdodCk7XG4gIGNvbnN0IHQgID0gKGZyYW1lSWR4IC0gMSkgLyAodG90YWxGcmFtZXMgLSAxKTtcblxuICBpZiAoZnJhbWVJZHggPT09IDEpXG4gICAgcmV0dXJuIGRyYXdJbWFnZUJvdHRvbUNlbnRlcihjdHgsIGZyb21JbWcudXJsLCBmcm9tSW1nLndpZHRoLCBmcm9tSW1nLmhlaWdodCwgY3csIGNoKTtcbiAgaWYgKGZyYW1lSWR4ID09PSB0b3RhbEZyYW1lcylcbiAgICByZXR1cm4gZHJhd0ltYWdlQm90dG9tQ2VudGVyKGN0eCwgdG9JbWcudXJsLCB0b0ltZy53aWR0aCwgdG9JbWcuaGVpZ2h0LCBjdywgY2gpO1xuXG4gIGNvbnN0IHBhbCA9XG4gICAgZnJhbWVJZHggPD0gNiA/IGZyb21JbWcudG9wTiA6XG4gICAgZnJhbWVJZHggPD0gOSA/IHVuaW9uUGFsZXR0ZXMoZnJvbUltZy50b3BOLCB0b0ltZy50b3BOKSA6XG4gICAgICAgICAgICAgICAgICAgIHRvSW1nLnRvcE47XG5cbiAgZHJhd1NkZk1vcnBoKGN0eCwgZnJvbUltZywgdG9JbWcsIGN3LCBjaCwgdCwgcGFsLCBxdWFudCk7XG59XG5cbi8q4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAIHByZXByb2Nlc3NpbmcgKHVuY2hhbmdlZCkg4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSA4pSAKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUltYWdlRGF0YShpbWcsIHRvcE4gPSBOVU1fQ09MT1JTKSB7XG4gIGNvbnN0IHsgd2lkdGg6IHcsIGhlaWdodDogaCB9ID0gaW1nO1xuICBjb25zdCBjYW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHcsIGgpO1xuICBjb25zdCBjICAgPSBjYW4uZ2V0Q29udGV4dCgnMmQnLCB7IHdpbGxSZWFkRnJlcXVlbnRseTp0cnVlIH0pO1xuICBjLmRyYXdJbWFnZShpbWcsIDAsIDApO1xuXG4gIGNvbnN0IGQgPSBjLmdldEltYWdlRGF0YSgwLCAwLCB3LCBoKS5kYXRhO1xuICBjb25zdCBjb2xvdXJzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDpoIH0sICgpID0+IEFycmF5KHcpKTtcbiAgY29uc3QgaW5zaWRlICA9IG5ldyBVaW50OEFycmF5KHcqaCk7XG4gIGNvbnN0IGZyZXEgICAgPSBuZXcgTWFwKCk7XG5cbiAgZm9yIChsZXQgaT0wO2k8ZC5sZW5ndGg7aSs9NCl7XG4gICAgY29uc3QgaWR4PWk+PjIseD1pZHgldyx5PWlkeC93fDA7XG4gICAgY29uc3QgcmdiYT1bZFtpXSxkW2krMV0sZFtpKzJdLGRbaSszXV07XG4gICAgY29sb3Vyc1t5XVt4XT1yZ2JhO1xuICAgIGlmIChyZ2JhWzNdPjIwKXsgaW5zaWRlW2lkeF09MTsgZnJlcS5zZXQocmdiYS5qb2luKCcsJyksIChmcmVxLmdldChyZ2JhLmpvaW4oJywnKSl8fDApKzEpOyB9XG4gIH1cblxuICBjb25zdCBib3VuZGFyeT1bXTtcbiAgZm9yKGxldCB5PTA7eTxoO3krKylmb3IobGV0IHg9MDt4PHc7eCsrKXtcbiAgICBjb25zdCBpZHg9eSp3K3gsaW5TPWluc2lkZVtpZHhdO1xuICAgIGZvcihsZXQgZHk9LTE7ZHk8PTEgJiYgIWJvdW5kYXJ5W2lkeF07ZHkrKylcbiAgICAgIGZvcihsZXQgZHg9LTE7ZHg8PTE7ZHgrKyl7XG4gICAgICAgIGlmKCFkeCAmJiAhZHkpY29udGludWU7XG4gICAgICAgIGNvbnN0IG54PXgrZHgsbnk9eStkeTtcbiAgICAgICAgaWYobng8MHx8bnk8MHx8bng+PXd8fG55Pj1oKWNvbnRpbnVlO1xuICAgICAgICBpZihpbnNpZGVbbnkqdytueF0hPT1pblMpYm91bmRhcnkucHVzaCh7eCx5fSksZHk9MjtcbiAgICAgIH1cbiAgfVxuXG4gIGNvbnN0IHNkZiA9IEFycmF5LmZyb20oe2xlbmd0aDpofSwoKT0+QXJyYXkodykpO1xuICBmb3IobGV0IHk9MDt5PGg7eSsrKWZvcihsZXQgeD0wO3g8dzt4Kyspe1xuICAgIGxldCBtPTEvMDtcbiAgICBmb3IoY29uc3QgYiBvZiBib3VuZGFyeSl7XG4gICAgICBjb25zdCBkeD1iLngteCxkeT1iLnkteSwgZDI9ZHgqZHgrZHkqZHk7XG4gICAgICBpZihkMjxtKW09ZDI7XG4gICAgfVxuICAgIHNkZlt5XVt4XT0oaW5zaWRlW3kqdyt4XT8gLTE6MSkqTWF0aC5zcXJ0KG0pO1xuICB9XG5cbiAgY29uc3QgdG9wID0gWy4uLmZyZXFdLnNvcnQoKGEsYik9PmJbMV0tYVsxXSlcbiAgICAgICAgICAgICAgIC5zbGljZSgwLHRvcE4pXG4gICAgICAgICAgICAgICAubWFwKChba10pPT5rLnNwbGl0KCcsJykubWFwKG49PituKSk7XG4gIHJldHVybiB7IHNkZiwgYWxsQ29sb3JzOiBjb2xvdXJzLCB0b3BOOiB0b3AsIHdpZHRoOncsIGhlaWdodDpoLCB1cmw6IGltZy5zcmMgfTtcbn1cbiJdLCJuYW1lcyI6WyJOVU1fQ09MT1JTIiwiZHJhd0ltYWdlQm90dG9tQ2VudGVyIiwiY3R4Iiwic3JjIiwidyIsImgiLCJjdyIsImNoIiwiaW1nIiwiSW1hZ2UiLCJjcm9zc09yaWdpbiIsIm9ubG9hZCIsImRyYXdJbWFnZSIsIm5lYXJlc3RDb2xvckluUGFsZXR0ZSIsInBhbCIsInIiLCJnIiwiYiIsImEiLCJsZW5ndGgiLCJiZXN0IiwiYmVzdEQiLCJjIiwiZCIsInVuaW9uUGFsZXR0ZXMiLCJzZWVuIiwiU2V0IiwibWFwIiwiam9pbiIsInMiLCJzcGxpdCIsIm4iLCJkcmF3U2RmTW9ycGgiLCJmcm9tSW1nIiwidG9JbWciLCJ0IiwicXVhbnQiLCJvdXQiLCJjcmVhdGVJbWFnZURhdGEiLCJkYXRhIiwib1hBIiwid2lkdGgiLCJvWUEiLCJoZWlnaHQiLCJvWEIiLCJvWUIiLCJ5IiwieCIsImkiLCJzZEEiLCJjQSIsImx4IiwibHkiLCJzZGYiLCJhbGxDb2xvcnMiLCJzZEIiLCJjQiIsInNkIiwibWl4IiwicGFsQyIsInB1dEltYWdlRGF0YSIsImRyYXdNb3JwaEZyYW1lIiwiZnJhbWVJZHgiLCJ0b3RhbEZyYW1lcyIsIk1hdGgiLCJtYXgiLCJ1cmwiLCJ0b3BOIiwiZ2VuZXJhdGVJbWFnZURhdGEiLCJjYW4iLCJPZmZzY3JlZW5DYW52YXMiLCJnZXRDb250ZXh0Iiwid2lsbFJlYWRGcmVxdWVudGx5IiwiZ2V0SW1hZ2VEYXRhIiwiY29sb3VycyIsIkFycmF5IiwiZnJvbSIsImluc2lkZSIsIlVpbnQ4QXJyYXkiLCJmcmVxIiwiTWFwIiwiaWR4IiwicmdiYSIsInNldCIsImdldCIsImJvdW5kYXJ5IiwiaW5TIiwiZHkiLCJkeCIsIm54IiwibnkiLCJwdXNoIiwibSIsImQyIiwic3FydCIsInRvcCIsInNvcnQiLCJzbGljZSIsImsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/sdf-morph.js\n"));

/***/ })

});